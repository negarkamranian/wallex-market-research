from fastapi import APIRouter, HTTPException, status
from typing import Dict, Any

from app.api.models import ResearchRequest, ResearchResponse, ErrorResponse
from app.agent.market_agent import market_agent
from app.db.postgres import research_repository
from app.db.mongodb import mongodb_client
from app.core.logging import get_logger

logger = get_logger(__name__)

router = APIRouter()


@router.post(
    "/research",
    response_model=ResearchResponse,
    status_code=status.HTTP_200_OK,
    responses={
        500: {"model": ErrorResponse, "description": "Internal server error"},
        400: {"model": ErrorResponse, "description": "Bad request"},
    },
    summary="Generate market research report",
    description="Analyze a cryptocurrency asset and return a risk assessment report generated by an AI agent."
)
async def conduct_research(request: ResearchRequest) -> ResearchResponse:
    """Conduct market research for an asset.
    
    This endpoint:
    1. Stores the research request in PostgreSQL
    2. Executes the AI agent to analyze the asset
    3. Stores the final report in PostgreSQL
    4. Logs execution details to MongoDB (non-blocking)
    5. Returns the structured research report
    
    Args:
        request: Research request containing asset symbol
        
    Returns:
        Research response with risk assessment
        
    Raises:
        HTTPException: If research fails
    """
    asset = request.asset.upper()
    logger.info(f"Received research request for asset: {asset}")
    
    try:
        db_request = research_repository.create_request(asset)
        logger.info(f"Created research request with id: {db_request.id}")
        
        logger.info(f"Executing AI agent for {asset}")
        research_result = market_agent.research(asset)
        
        output = research_result["output"]
        agent_steps = research_result["agent_steps"]
        tool_calls = research_result["tool_calls"]
        execution_time_ms = research_result["execution_time_ms"]
        
        logger.info(f"AI agent completed successfully in {execution_time_ms:.2f}ms")
        
        db_report = research_repository.create_report(
            request_id=db_request.id,
            asset=output["asset"],
            risk_level=output["risk_level"],
            sentiment_score=output["sentiment_score"],
            tools_used=output["tools_used"],
            report_data=output
        )
        logger.info(f"Stored research report with id: {db_report.id}")
        
        # This should not fail the request even if MongoDB is unavailable
        try:
            mongodb_client.log_execution(
                request_id=db_request.id,
                asset=asset,
                agent_steps=agent_steps,
                tool_calls=tool_calls,
                final_output=output,
                execution_time_ms=execution_time_ms,
                success=True,
                error=None
            )
        except Exception as mongo_error:
            logger.warning(f"MongoDB logging failed (non-critical): {mongo_error}")
        
        return ResearchResponse(
            asset=output["asset"],
            risk_level=output["risk_level"],
            sentiment_score=output["sentiment_score"],
            tools_used=output["tools_used"]
        )
        
    except Exception as e:
        logger.error(f"Research failed for {asset}: {e}", exc_info=True)
        
        try:
            if 'db_request' in locals():
                mongodb_client.log_execution(
                    request_id=db_request.id,
                    asset=asset,
                    agent_steps=[],
                    tool_calls=[],
                    final_output={},
                    execution_time_ms=0,
                    success=False,
                    error=str(e)
                )
        except:
            pass  # Ignore MongoDB errors during error handling
        
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Research failed: {str(e)}"
        )


@router.get(
    "/health",
    summary="Health check",
    description="Check if the service is running and databases are accessible"
)
async def health_check() -> Dict[str, Any]:
    """Health check endpoint.
    
    Returns:
        Health status of the service and its dependencies
    """
    health_status = {
        "status": "healthy",
        "service": "market-research-api",
        "databases": {
            "postgresql": "unknown",
            "mongodb": "unknown"
        }
    }
  
    try:
        session = research_repository.db_client.get_session()
        session.close()
        health_status["databases"]["postgresql"] = "connected"
    except Exception as e:
        health_status["databases"]["postgresql"] = f"error: {str(e)}"
        health_status["status"] = "degraded"
    
    if mongodb_client.is_available():
        health_status["databases"]["mongodb"] = "connected"
    else:
        health_status["databases"]["mongodb"] = "unavailable (non-critical)" # MongoDB is optional
